import matplotlib.pyplot as plt
import mysql.connector
from mysql.connector import errorcode
import time
import os
from pathlib import Path
import os.path
import folium
import functools
import operator
from datetime import datetime
import folium.plugins
from folium.plugins import HeatMap
from folium.plugins import MiniMap
from folium.plugins import MeasureControl
from folium.plugins import MousePosition
import plotly.graph_objects as go
import plotly.express as px
import pandas as pd


class Connection():
    def __init__(self):
        pass

    def _ClearTerminal(self):
        if os.name == 'nt':  # Windows
            os.system('cls')
        elif os.name == 'posix':  # Mac or Linux
            os.system('clear')

    def _ConnectionDetails(self):
        host = input("Enter host name: ")
        UserName = input("Enter username: ")
        PassWord = input("Enter password: ")
        try:
            con = mysql.connector.connect(
                host=host,
                user=UserName,
                password=PassWord
            )
            con.close()
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_ACCESS_DENIED_ERROR:
                print("INCORRECT USERNAME OR PASSWORD")
                time.sleep(0.5)
                exit()
            else:
                print(err)
                time.sleep(0.5)
                exit()
        con.close()
        time.sleep(0.5)
        self._ClearTerminal()
        Details = [host, UserName, PassWord]
        return Details


class ConnectionFile(Connection):
    def __init__(self):
        super().__init__()

    def ConnectionFileReading(self):
        base_folder = Path(__file__).parent.resolve()
        connnectiondetails = base_folder / "connectiondetails.txt"
        if os.path.isfile(connnectiondetails):
            text_file = open(connnectiondetails, "r")
            details = text_file.read().split(',')
        else:
            details = super()._ConnectionDetails()
            with open(connnectiondetails, 'w') as f:
                f.write(details[0] + ",")
                f.write(details[1] + ",")
                f.write(details[2])
        return details


class Login(ConnectionFile):
    def __init__(self):
        super().__init__()

    def Login(self):
        Result = []
        while len(Result) == 0:
            Details = super().ConnectionFileReading()
            self.BMFAID = input('Enter BMFA id: ')
            self.Name = input("Enter name: ")
            self.Password = input('Enter password: ')
            con = mysql.connector.connect(host=Details[0], user=Details[1], password=Details[2])
            cursor = con.cursor()
            LoginDetails = [self.BMFAID, self.Name, self.Password]
            SQL = "Select Table_SCHEMA FROM information_schema.COLUMNS WHERE TABLE_NAME = 'SensorData' LIMIT 1"
            con = mysql.connector.connect(host=Details[0], user=Details[1], password=Details[2])
            cursor = con.cursor()
            cursor.execute(SQL)
            database = cursor.fetchone()
            SQL = """SELECT Admin FROM """ + functools.reduce(operator.add, database[
                0]) + ".Users" + """ WHERE BMFAID = %s AND Username = %s AND Password = %s"""
            cursor.execute(SQL, LoginDetails)
            Result = cursor.fetchall()
            cursor.close()
            con.close()
            super()._ClearTerminal()
            if len(Result) <= 0:
                print("Incorrect BMFAID or Incorrect Name or Incorrect Password")
                time.sleep(1)
                super()._ClearTerminal()
        con = mysql.connector.connect(host=Details[0], user=Details[1], password=Details[2])
        cursor = con.cursor()
        SQL = """SELECT SerialID FROM """ + functools.reduce(operator.add, database[
            0]) + """.Users""" + """ WHERE BMFAID = %s AND Username = %s AND Password = %s"""
        cursor.execute(SQL, LoginDetails)
        SerialID = cursor.fetchone()
        SQL = """SELECT RaspberryPiID FROM """ + functools.reduce(operator.add, database[
            0]) + """.Users""" + """ WHERE BMFAID = %s AND Username = %s AND Password = %s"""
        cursor.execute(SQL, LoginDetails)
        RaspberryPiID = cursor.fetchone()
        SQL = """SELECT Admin FROM """ + functools.reduce(operator.add, database[
            0]) + """.Users""" + """ WHERE BMFAID = %s AND Username = %s AND Password = %s"""
        cursor.execute(SQL, LoginDetails)
        Admin = cursor.fetchone()
        cursor.close()
        con.close()
        LoginDetails = [SerialID, RaspberryPiID, Admin]
        return LoginDetails


class DataBaseLocation(Login):
    def __init__(self):
        super().__init__()

    def _ChoosingGPSTable(self, host, database, UserName, Password, Admin):
        table1 = ""
        Flag = False
        while Flag == False:
            super()._ClearTerminal()
            SQL = "SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = " + "'" + functools.reduce(
                operator.add, database) + "'" + ";"
            con = mysql.connector.connect(host=host, user=UserName, password=Password)
            cursor = con.cursor()
            cursor.execute(SQL)
            Details = cursor.fetchall()
            for i in range(0, len(Details)):
                print(str(i + 1) + ") " + functools.reduce(operator.add, Details[i]))
            cursor.close()
            con.close()
            UC = input("Choose table for GPS data to be taken from: ")
            if UC.isnumeric() == True:
                if 1 <= int(UC) <= len(Details):
                    table1 = Details[int(UC) - 1]
                    time.sleep(0.5)
                    super()._ClearTerminal()
                    Flag = True
                else:
                    super()._ClearTerminal()
                    print("Invalid input")
                    time.sleep(1)
            elif UC == "X":
                super()._ClearTerminal()
                Flag = True
                self.ChoosingDataBaseLocation(host, UserName, Password, Admin)
            else:
                super()._ClearTerminal()
                print("Invalid input")
                time.sleep(1)
            return table1

    def _ChoosingSensorTable(self, host, database, UserName, Password, Admin):
        table2 = ""
        Flag = False
        while Flag == False:
            super()._ClearTerminal()
            SQL = "SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = " + "'" + functools.reduce(
                operator.add, database) + "'" + ";"
            con = mysql.connector.connect(host=host, user=UserName, password=Password)
            cursor = con.cursor()
            cursor.execute(SQL)
            Details = cursor.fetchall()
            for i in range(0, len(Details)):
                print(str(i + 1) + ") " + functools.reduce(operator.add, Details[i]))
            cursor.close()
            con.close()
            UC = input("Choose table for Sensor data to be taken from: ")
            if UC.isnumeric() == True:
                if 1 <= int(UC) <= len(Details):
                    table2 = Details[int(UC) - 1]
                    time.sleep(0.5)
                    super()._ClearTerminal()
                    Flag = True
                else:
                    super()._ClearTerminal()
                    print("Invalid input")
                    time.sleep(1)
            else:
                super()._ClearTerminal()
                print("Invalid input")
                time.sleep(1)
        return table2

    def ChoosingDataBaseLocation(self, host, UserName, Password, Admin):
        Flag = False
        if Admin == 1:
            super()._ClearTerminal()
            con = mysql.connector.connect(host=host, user=UserName, password=Password)
            cursor = con.cursor()
            SQL = "SELECT DISTINCT TABLE_SCHEMA FROM INFORMATION_SCHEMA.COLUMNS;"
            cursor.execute(SQL)
            Details = cursor.fetchall()
            while Flag == False:
                super()._ClearTerminal()
                for i in range(0, len(Details)):
                    print(str(i + 1) + ") " + functools.reduce(operator.add, Details[i]))
                cursor.close()
                con.close()
                UC = input("Choose database for data to be taken from: ")
                if UC.isnumeric() == True:
                    if 1 <= int(UC) <= len(Details):
                        database = Details[int(UC) - 1]
                        time.sleep(0.5)
                        super()._ClearTerminal()
                        Flag = True
                    else:
                        super()._ClearTerminal()
                        print("Invalid input")
                        time.sleep(1)
                else:
                    super()._ClearTerminal()
                    print("Invalid input")
                    time.sleep(1)
            table1 = self._ChoosingGPSTable(host, database, UserName, Password, Admin)
            table2 = self._ChoosingSensorTable(host, database, UserName, Password, Admin)
            DataLocation = [database, table1, table2]
            time.sleep(0.5)
            super()._ClearTerminal()
            return DataLocation

        elif Admin == 0:
            SQL = "Select Table_SCHEMA FROM information_schema.COLUMNS WHERE TABLE_NAME = 'SensorData' LIMIT 1"
            con = mysql.connector.connect(host=host, user=UserName, password=Password)
            cursor = con.cursor()
            cursor.execute(SQL)
            database = cursor.fetchall()
            cursor.close()
            con.close()
            table1 = "GPSData"
            table2 = "SensorData"
            DataLocation = [database, table1, table2]
            return DataLocation

class Menu(DataBaseLocation):
    def __init__(self, host, UserName, Password, SerialID, RaspberryPiID, database, GPSDataTable, SensorDataTable,
                 Admin):
        super().__init__()
        self.host = host
        self.database = database
        self.UserName = UserName
        self.Password = Password
        self.Admin = Admin
        self.RaspberryPiID = RaspberryPiID
        self.SerialID = SerialID
        self.GPSDataTable = GPSDataTable
        self.SensorDataTable = SensorDataTable

    def _MenuOptions(self):
        print("-------------------------Menu----------------------------------")
        print("1) Plot map of flight path")
        print("2) Plot graph of altitude against time")
        print("3) Plot graph of GPS speed against time")
        print("4) Plot graph of number of satellites against time")
        print("5) Plot graph of temperature against time")
        print("6) Plot graph of acceleration against time")
        print("7) Plot graph of acceleration x against time")
        print("8) Plot graph of acceleration y against time")
        print("9) Plot graph of acceleration z against time")
        print("10) Plot graph of pressure against time")
        print("11) Plot graph of humidity against time")
        print("12) Plot graph of altitude determined from pressure against time")
        print("13) Plot graph of magnetic field strength against time")
        print("14) Plot graph of luminosity against time")
        print("15) Plot graph of red light against time")
        print("16) Plot graph of green light against time")
        print("17) Plot graph of blue light against time")
        print("18) Plot custom graph")
        print("19) Plot flight path on map of choosing")

    def _SerialID(self):
        Flag = False
        if self.Admin == 1:
            while not Flag:
                Flag = False
                print("Current Serial ID: " + str(self.SerialID))
                UC = input("Enter X to continue with current Serial id or enter new Serial ID to create graph for: ")
                if UC == "X":
                    Flag = True
                    return self.SerialID
                elif len(UC) == 16:
                    if UC.isnumeric():
                        Flag = True
                        return UC
                else:
                    Flag = False
        elif self.Admin == 0:
            return self.SerialID

    def _RaspberryPiID(self):
        Flag = False
        if self.Admin == 1:
            while not Flag:
                Flag = False
                print("Current Raspberry Pi ID: " + str(self.RaspberryPiID))
                UC = input(
                    "Enter X to continue with current Raspberry Pi ID or enter new Raspberry Pi ID to create graph for: ")
                if UC == "X":
                    Flag = True
                    return self.RaspberryPiID
                elif len(UC) == 16:
                    if UC.isnumeric():
                        Flag = True
                        return UC
                else:
                    Flag = False
        elif self.Admin == 0:
            return self.RaspberryPiID

    def _DateTime(self):
        Flag = False
        while not Flag:
            UC = input("Enter start date and time in the format DD-MM-YYYY  HH:MM:SS: ")
            try:
                StartDateTime = datetime.strptime(UC, '%d/%m/%Y %H:%M:%S')
                Flag = True
            except Exception as e:
                super()._ClearTerminal()
                print("Invalid input")
                time.sleep(1)
        Flag = False
        while not Flag:
            UC = input("Enter end date and time in the format DD-MM-YYYY  HH:MM:SS: ")
            try:
                EndDateTime = datetime.strptime(UC, '%d/%m/%Y %H:%M:%S')
                Flag = True
            except Exception as e:
                super()._ClearTerminal()
                print("Invalid input")
                time.sleep(1)
        StartDateTime = datetime.timestamp(StartDateTime)
        EndDateTime = datetime.timestamp(EndDateTime)
        StartEnd = [StartDateTime, EndDateTime]
        return StartEnd

    def _FlightPath(self):
        print("1) Interactive flight map")
        print("2) Static flight map")
        UC = input("Do you wish to have a heatmap of the plane's speed Y/N: ")
        Flag = False
        HeatMapOption = False
        while not Flag:
            if UC == "Y":
                Flag = True
                HeatMapOption = True
            elif UC == "N":
                Flag = True
                HeatMapOption = False
            else:
                Flag = False
                super()._ClearTerminal()
                print("Invalid input")

        Longitude = []
        Latitude = []
        Coordinates = []
        self.SerialID = self._SerialID()
        StartEndDateTime = self._DateTime()
        insert = [(functools.reduce(operator.add, self.SerialID))]
        SQL = "SELECT Latitude,Longitude FROM " + str(functools.reduce(operator.add, self.database)) + "." + str(
            functools.reduce(operator.add, self.GPSDataTable)) + " WHERE " + str(
            StartEndDateTime[0]) + " <= TimeStamp <= " + str(StartEndDateTime[1]) + " AND SerialID =  %s "
        con = mysql.connector.connect(host=self.host, user=self.UserName, password=self.Password)
        cursor = con.cursor()
        cursor.execute(SQL, insert)
        data = cursor.fetchall()
        cursor.close()
        con.close()
        for i in data:
            Latitude.append(i[0])
            Longitude.append(i[1])
        m = folium.Map(location=[Latitude[0], Longitude[0]], zoom_start=5, control_scale=True, max_bounds=True)
        fg = folium.FeatureGroup(name="Markers", show=False).add_to(m)
        eg = folium.FeatureGroup(name="Plane Path", show=True).add_to(m)
        folium.Marker(location=[Latitude[0], Longitude[0]], popup=folium.Popup(
            "This is the start point of the plane at " + str(datetime.fromtimestamp(StartEndDateTime[0])))).add_to(fg)
        folium.Marker(location=[Latitude[len(Longitude) - 1], Longitude[len(Longitude) - 1]], popup=folium.Popup(
            "This is the end point of the plane at " + str(datetime.fromtimestamp(StartEndDateTime[0])))).add_to(fg)
        for i in range(0, len(Latitude) - 1):
            Coordinates.append([Latitude[i], Longitude[i]])
        folium.PolyLine(locations=Coordinates, color="a0437F2", weight=5, tooltip="Plane Path").add_to(eg)
        folium.plugins.Fullscreen(position="topright", title="Expand me", title_cancel="Exit me",
                                  force_separate_button=True).add_to(m)
        folium.plugins.LocateControl(auto_start=True).add_to(m)
        MousePosition().add_to(m)
        MiniMap(toggle_display=True).add_to(m)
        m.add_child(MeasureControl())
        if HeatMapOption:
            HeatMapData = []
            SQL = "SELECT GPSSpeed FROM " + str(functools.reduce(operator.add, self.database)) + "." + str(
                functools.reduce(operator.add, self.GPSDataTable)) + " WHERE " + str(
                StartEndDateTime[0]) + " <= TimeStamp <= " + str(StartEndDateTime[1]) + " AND SerialID =  %s "
            con = mysql.connector.connect(host=self.host, user=self.UserName, password=self.Password)
            cursor = con.cursor()
            cursor.execute(SQL, insert)
            data = cursor.fetchall()
            cursor.close()
            con.close()
            counter = 0
            for i in data:
                HeatMapData.append([Latitude[counter], Longitude[counter], functools.reduce(operator.add, i)])
                counter = counter + 1
            cg = folium.FeatureGroup(name="HeatMap", show=False).add_to(m)
            HeatMap(HeatMapData).add_to(cg)
        folium.LayerControl().add_to(m)
        m.show_in_browser()
        m.save("Plane_Path.html")

    def _LongitudeAndLatitude(self):
        self.SerialID = self._SerialID()
        StartEndDateTime = self._DateTime()
        insert = [(functools.reduce(operator.add, self.SerialID))]
        SQL = "SELECT Latitude,Longitude FROM " + str(functools.reduce(operator.add, self.database)) + "." + str(
            functools.reduce(operator.add, self.GPSDataTable)) + " WHERE " + str(
            StartEndDateTime[0]) + " <= TimeStamp <= " + str(StartEndDateTime[1]) + " AND SerialID =  %s "
        con = mysql.connector.connect(host=self.host, user=self.UserName, password=self.Password)
        cursor = con.cursor()
        cursor.execute(SQL, insert)
        data = cursor.fetchall()
        cursor.close()
        con.close()
        Longitude = []
        Latitude = []
        Coordinates = []
        for i in data:
            Coordinates.append((i[0], i[1]))
        fig = go.Figure(go.Scattergeo())
        map_projections = [
            "airy", "aitoff", "albers", "albers usa", "august", "azimuthal equal area",
            "azimuthal equidistant", "baker", "bertin1953", "boggs", "bonne", "bottomley",
            "bromley", "collignon", "conic conformal", "conic equal area", "conic equidistant",
            "craig", "craster", "cylindrical equal area", "cylindrical stereographic",
            "eckert1", "eckert2", "eckert3", "eckert4", "eckert5", "eckert6", "eisenlohr",
            "equal earth", "equirectangular", "fahey", "foucaut", "foucaut sinusoidal",
            "ginzburg4", "ginzburg5", "ginzburg6", "ginzburg8", "ginzburg9", "gnomonic",
            "gringorten", "gringorten quincuncial", "guyou", "hammer", "hill", "homolosine",
            "hufnagel", "hyperelliptical", "kavrayskiy7", "lagrange", "larrivee", "laskowski",
            "loximuthal", "mercator", "miller", "mollweide", "mt flat polar parabolic",
            "mt flat polar quartic", "mt flat polar sinusoidal", "natural earth", "natural earth1",
            "natural earth2", "nell hammer", "nicolosi", "orthographic", "patterson",
            "peirce quincuncial", "polyconic", "rectangular polyconic", "robinson", "satellite",
            "sinu mollweide", "sinusoidal", "stereographic", "times", "transverse mercator",
            "van der grinten", "van der grinten2", "van der grinten3", "van der grinten4",
            "wagner4", "wagner6", "wiechel", "winkel tripel", "winkel3"
        ]
        for i in range(0, len(map_projections) - 1):
            print(str(i) + ") " + map_projections[i])
        UC = input("Choose a map projection: ")
        Flag = False
        while not Flag:
            if UC.isnumeric():
                if 0 < int(UC) < 97:
                    Flag = True
                    import plotly.io as pio
                    pio.renderers.default = "browser"
                    df = pd.DataFrame(Coordinates, columns=["Latitude", "Longitude"])
                    fig = px.scatter_geo(df, lat="Latitude", lon="Longitude")
                    fig.update_geos(projection_type=map_projections[int(UC)])
                    fig.update_layout(height=300, margin={"r": 0, "t": 0, "l": 0, "b": 0})
                    fig.show()
                    time.sleep(20)
                else:
                    super()._ClearTerminal()
                    print("Invalid Input")
                    time.sleep(10)
                    super()._ClearTerminal()
                    for i in range(0, len(map_projections) - 1):
                        print(str(i) + ") " + map_projections[i])
                    UC = input("Choose a map projection: ")
            else:
                super()._ClearTerminal()
                print("Invalid Input")
                time.sleep(1)
                super()._ClearTerminal()
                for i in range(0, len(map_projections) - 1):
                    print(str(i) + ") " + map_projections[i])
                UC = input("Choose a map projection: ")
        self.Menu()

    def _AltitudeGraph(self):
        self.SerialID = self._SerialID()
        StartEndDateTime = self._DateTime()
        insert = [(functools.reduce(operator.add, self.SerialID))]
        SQL = "SELECT TimeStamp,GPSAltitude FROM " + str(functools.reduce(operator.add, self.database)) + "." + str(
            functools.reduce(operator.add, self.GPSDataTable)) + " WHERE " + str(
            StartEndDateTime[0]) + " <= TimeStamp <= " + str(StartEndDateTime[1]) + " AND SerialID =  %s "
        con = mysql.connector.connect(host=self.host, user=self.UserName, password=self.Password)
        cursor = con.cursor()
        cursor.execute(SQL, insert)
        data = cursor.fetchall()
        cursor.close()
        con.close()
        Time = []
        Elevation = []
        for i in data:
            Time.append(datetime.fromtimestamp(i[0]))
            Elevation.append(i[1])
        plt.plot(Time, Elevation)
        plt.xlabel = "Date Time"
        plt.ylabel = "Elevation / Metres"
        plt.title = "Elevation against time"
        plt.tick_params(bottom=False, labelbottom=False)
        plt.show()

    def _SpeedGraph(self):
        self.SerialID = self._SerialID()
        StartEndDateTime = self._DateTime()
        insert = [(functools.reduce(operator.add, self.SerialID))]
        SQL = "SELECT TimeStamp,GPSSpeed FROM " + str(functools.reduce(operator.add, self.database)) + "." + str(
            functools.reduce(operator.add, self.GPSDataTable)) + " WHERE " + str(
            StartEndDateTime[0]) + " <= TimeStamp <= " + str(StartEndDateTime[1]) + " AND SerialID =  %s "
        con = mysql.connector.connect(host=self.host, user=self.UserName, password=self.Password)
        cursor = con.cursor()
        cursor.execute(SQL, insert)
        data = cursor.fetchall()
        cursor.close()
        con.close()
        Time = []
        Speed = []
        for i in data:
            Time.append(datetime.fromtimestamp(i[0]))
            Speed.append(i[1])
        plt.plot(Time, Speed)
        plt.xlabel = "Date Time"
        plt.ylabel = "Speed / Metres per second"
        plt.title = "GPS Speed against time"
        plt.tick_params(bottom=False, labelbottom=False)
        plt.show()
